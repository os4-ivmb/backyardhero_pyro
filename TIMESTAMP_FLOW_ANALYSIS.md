# Timestamp ('t' / 'lmt') Communication Flow Analysis

## Overview
This document traces the complete communication flow for the `'t'` field (mapped to `'lmt'` - last message time) from receiver → dongle → Python daemon.

## Key Insight: The Timestamp is NOT from the Receiver
**Critical Finding:** The receiver status message does NOT contain a timestamp. The `'t'` value is generated by the dongle when it receives the status message.

---

## Step-by-Step Flow

### 1. RECEIVER SIDE (os4_receiver.ino)

#### When Status is Sent:
- **After receiving commands** (line 1135): `sendStatus()` is called immediately
- **Periodically when idle** (line 1217): Every 2 seconds (`STATUS_INTERVAL = 2000ms`) if no command received

#### Status Message Structure (lines 370-401):
```cpp
struct ReceiverStatusMessage {
  uint8_t type;           // RECEIVER_STATUS = 10
  uint8_t nodeID;
  uint8_t batteryLevel;
  uint16_t showState;      // Contains showId, loadComplete, startReady flags
  char ident[10];          // Receiver identifier (e.g., "RX121")
  uint64_t cont64_0;       // Continuity bitmask 1
  uint64_t cont64_1;       // Continuity bitmask 2
  // NOTE: NO TIMESTAMP FIELD!
}
```

**Key Point:** The receiver status message contains NO timestamp. It only contains status data.

#### Receiver Clock Synchronization:
- Receiver uses `getSynchronizedTime()` = `millis() + clock_offset` (line 213-215)
- `clock_offset` is set via `handleClockSync()` when receiving CLOCK_SYNC messages (line 227-233)
- However, this synchronized time is NOT sent in the status message

---

### 2. DONGLE SIDE (os4_dongle.ino)

#### Receiving Status Message (lines 1206-1239):
```cpp
void loop() {
  uint64_t now = millis() + tsOffset;  // Line 1174: Dongle's synchronized time
  
  while (radio.available()) {
    if (msgType == RECEIVER_STATUS) {
      ReceiverStatusMessage* status = (ReceiverStatusMessage*)buf;
      ReceiverInfo* r_from_msg = getReceiverByIdent(String(status->ident), true);
      
      if (r_from_msg) {
        // ... update other fields ...
        r_from_msg->lastMessageTime = now;  // Line 1239: SET TO DONGLE'S TIME
      }
    }
  }
}
```

**Critical Point:** `lastMessageTime` is set to the dongle's `now` value, which is:
- `now = millis() + tsOffset`
- `tsOffset` is set via `msync` command from Python (line 894-896)
- This is the dongle's synchronized time, NOT the receiver's time

#### Sending JSON to Python (lines 1579-1609):
```cpp
if (now - lastPrintTime >= 1000) {  // Every 1 second
  lastPrintTime = now;
  DynamicJsonDocument doc(...);
  doc["timestamp"] = now;  // Line 1582: Dongle's current time
  
  JsonArray receiversArray = doc.createNestedArray("receivers");
  for (uint8_t i = 0; i < numReceivers; i++) {
    JsonObject receiver = receiversArray.createNestedObject();
    // ... other fields ...
    receiver["t"] = receivers[i].lastMessageTime;  // Line 1604: Last time dongle received status
  }
  Serial.println(jsonOutput);  // Sent to Python via serial
}
```

**What gets sent:**
- `timestamp`: Dongle's current time when JSON is generated
- `receivers[].t`: The `lastMessageTime` value (when dongle last received status from that receiver)

---

### 3. PYTHON DAEMON SIDE (BYHProtocolHandler.py)

#### Receiving and Processing (lines 169-242):
```python
def process_status_msg(self, msg_obj):
    self.last_status_ts = msg_obj.get('timestamp', 0)  # Dongle's current time
    
    # Calculate offset between Python time and dongle time
    lmtoffset = int(time.time() * 1000) - msg_obj.get('timestamp', 0)  # Line 186
    
    for receiver in msg_obj.get('receivers', []):
        if receiver.get('i') in self.receivers:
            receiver_ident = receiver.get('i')
            existing_status = self.receivers[receiver_ident].get('status', {})
            existing_timestamp = existing_status.get('lmt', 0)
            
            # Process 't' field
            if 't' in receiver:
                adjusted_timestamp = receiver['t'] + lmtoffset  # Line 202
                
                # Only update if new timestamp is newer (or small backward jump for clock sync)
                timestamp_diff = adjusted_timestamp - existing_timestamp
                if timestamp_diff > -1000:  # Allow 1 second backward jump
                    full_receiver['lmt'] = adjusted_timestamp
                else:
                    full_receiver['lmt'] = existing_timestamp  # Keep old if stale
```

**Processing Steps:**
1. Extract `timestamp` from JSON (dongle's current time)
2. Calculate `lmtoffset = Python_time - dongle_timestamp` (clock drift compensation)
3. For each receiver's `'t'` value:
   - Add `lmtoffset` to convert from dongle time to Python time
   - Compare with existing timestamp to prevent stale data
   - Store as `'lmt'` in receiver status

---

## Clock Synchronization Chain

### Three-Level Clock Sync:

1. **Python → Dongle** (via `msync` command):
   - Python sends: `"msync 0 {python_time_ms}\n"`
   - Dongle sets: `tsOffset = python_time_ms - millis()`
   - Frequency: Every 20 seconds (default `dongle_sync_interval_ms`)

2. **Dongle → Receiver** (via `CLOCK_SYNC` message):
   - Dongle sends: `ClockSyncMessage` with `timestamp = now` (dongle's synchronized time)
   - Receiver sets: `clock_offset = msg->timestamp - millis()`
   - Frequency: Every 2 seconds (default `clockSyncIntervalMs`)

3. **Timestamp Adjustment** (Python processing):
   - Python calculates: `lmtoffset = Python_time - dongle_timestamp`
   - Adjusts receiver timestamps: `adjusted = receiver_t + lmtoffset`

---

## Potential Issues and Edge Cases

### Issue 1: Timestamp is Dongle's Reception Time, Not Receiver's Send Time
- The `'t'` value represents when the dongle **received** the status, not when the receiver **sent** it
- Radio transmission delay (~1-10ms) is not accounted for
- This is generally fine for latency calculations, but worth noting

### Issue 2: Clock Drift Between Syncs
- If dongle's clock drifts between `msync` commands (every 20s), `lmtoffset` calculation may be slightly off
- If receiver's clock drifts between `CLOCK_SYNC` messages (every 2s), receiver's synchronized time may drift
- However, since `'t'` is set by dongle (not receiver), receiver clock drift doesn't directly affect it

### Issue 3: Stale Timestamp Prevention
- Python code prevents stale timestamps from overwriting valid ones (line 207-212)
- Allows up to 1 second backward jump for clock sync adjustments
- If a receiver stops sending status, its timestamp won't update, correctly showing increasing latency

### Issue 4: Status Message Frequency Mismatch
- Receivers send status every 2 seconds (when idle)
- Dongle sends JSON every 1 second
- This means dongle may send the same `lastMessageTime` value twice in a row
- Python's stale timestamp prevention handles this correctly

### Issue 5: Queue Blocking
- If dongle's command queue is full, status messages might be processed with delay
- This could cause `lastMessageTime` to be set later than actual reception
- However, the blocking approach waits for responses, so this should be minimal

---

## Summary

**The `'t'` / `'lmt'` value represents:**
- **What:** The dongle's synchronized time when it last received a status message from the receiver
- **When:** Updated every time dongle receives a `RECEIVER_STATUS` message
- **How:** Set to `millis() + tsOffset` (dongle's synchronized time)
- **Why:** Used to calculate latency (time since last status message)

**Key Takeaways:**
1. Receiver status messages contain NO timestamp
2. Dongle generates the timestamp when receiving the status
3. Timestamp is in dongle's time reference (synchronized with Python)
4. Python adjusts it to its own time reference using `lmtoffset`
5. Stale timestamp prevention ensures latency calculations are accurate

**The timestamp flow:**
```
Receiver sends status (no timestamp)
    ↓
Dongle receives → sets lastMessageTime = now (dongle time)
    ↓
Dongle sends JSON: {timestamp: now, receivers: [{t: lastMessageTime}]}
    ↓
Python receives → calculates lmtoffset → adjusts: lmt = t + lmtoffset
    ↓
Python stores as receiver.status.lmt (Python time reference)
```

