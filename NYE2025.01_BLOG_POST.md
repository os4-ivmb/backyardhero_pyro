# NYE2025.01 - Racks, YouTube Processing, and Actually Using This Thing

So it's been a minute since I've posted about Backyard Hero. The hardware side has been pretty solid for a while now - the receivers work, the cue modules work, everything talks to each other. But the software side... well, it was functional but not exactly what I'd call polished. This release changes that in a pretty significant way.

## Rack Editing - Finally

One of the things that's been bugging me is that I'd have to manually figure out which shells go where in a rack, then manually enter all the timing delays for fuse lines. It worked, but it was tedious as hell. So I built a proper rack editor.

[IMAGE_PLACEHOLDER: Screenshot of rack editor with grid layout]

You can now create racks with custom dimensions, drag shells onto specific cells, and visually build fuse lines. The system automatically calculates delays based on fuse burn rates. Want a 10x10 rack? Done. Want to fuse a line of shells together? Click and drag, select your fuse type, done. The visual representation makes it way easier to see what's going on.

[IMAGE_PLACEHOLDER: Screenshot showing fuse lines drawn on rack grid]

The rack system integrates with the show builder too - you can assign racks to receivers and the system handles all the cue mapping. No more manually counting cells and figuring out which receiver cue corresponds to which physical position.

But here's the thing - when you're assigning shells to rack spots, you want to be able to filter by color or effect. "I need a red shell here" or "I want something with strobes there." But if your inventory doesn't have colors and effects mapped, you're stuck manually looking through descriptions.

So I built an auto-processor for shell description lists. You paste in a list of shell descriptions (like you'd get from a manufacturer or distributor), and it automatically extracts colors and effects, maps them to standardized types, and creates inventory entries. Now when you're building a rack, you can filter shells by color or effect and pick exactly what you need.

[IMAGE_PLACEHOLDER: Screenshot of shell pack editor with parsed descriptions showing colors and effects]

The parser uses AI to understand firework terminology - it knows that "lemon" means yellow, "silver coconut palm" has both a color and an effect, and "peony to strobes" means it changes from one effect to another. It's not perfect, but it gets you 95% of the way there and you can tweak the results. Way better than manually entering colors and effects for every shell.

[IMAGE_PLACEHOLDER: Screenshot of rack editor with color/effect filters showing filtered shell selection]

## YouTube Video Processing - Because Manual Entry Sucks

I've got a bunch of shells in my inventory, and I know what they do because I've seen videos of them. But manually entering firing profiles? That's a hard pass. So I built a system that crawls YouTube videos and extracts firing profiles automatically.

[IMAGE_PLACEHOLDER: Screenshot of inventory with YouTube links and firing profiles]

The system downloads the audio from YouTube videos, analyzes it for shot timings, and creates firing profiles. It uses audio analysis to detect when shots go off - filtering out lift charges by using thresholds based on the loudest sounds. You can even have it populate color information if the video description or metadata has that data.

[IMAGE_PLACEHOLDER: Screenshot showing firing profile extraction process or results]

The processing happens in the background - you just paste a YouTube link and a start time, and it figures out the rest. It's not perfect (audio analysis is tricky), but it gets you 90% of the way there and you can tweak the results if needed. Way better than manually clicking through a timeline.

## Receiver Telemetry - Actually Knowing What's Going On

The receivers have always sent back status, but the UI wasn't really showing it in a useful way. Now you get real-time telemetry on everything:

- **Ready count**: How many receivers are actually ready to fire
- **Latency**: Round-trip communication time (with smoothing so it's not jumpy)
- **Success percentage**: How reliable the communication is with each receiver
- **Battery levels**: Obviously
- **Continuity status**: Per-cue feedback

[IMAGE_PLACEHOLDER: Screenshot of receiver status panel showing telemetry]

The UI shows all this with visual health indicators. Green is good, yellow is concerning, red is bad. Simple. You can see at a glance if a receiver is having communication issues or if something's wrong with continuity.

## Mesh Networking - Turns Out We Don't Need It

I originally designed the receivers with mesh networking in mind. The idea was that they'd relay messages to each other, extending range. But in practice? The direct range is already 1000+ yards, which is way more than I need. And mesh networking adds overhead - more complexity, more power consumption, more things that can go wrong.

[IMAGE_PLACEHOLDER: Photo of receiver in field or range test setup]

So I ripped it out. The receivers now use raw point-to-point communication. It's simpler, more reliable, and the range is still excellent. Sometimes the simple solution is the right solution.

## Pyromusical Support - Because Music Makes Everything Better

I've been wanting to do music-synchronized shows for a while. The system now supports uploading audio files and syncing cues to the music timeline.

[IMAGE_PLACEHOLDER: Screenshot of show builder with audio waveform timeline]

The timeline shows a waveform visualization, so you can see the music and place cues at the right moments. It's not perfect (audio sync is hard), but it's functional and makes it way easier to build pyromusical shows.

## Reliability Fixes - The Boring But Important Stuff

There were a bunch of edge cases and failure modes that I've been fixing:

- Better error recovery when receivers lose connection
- Improved retry logic for failed transmissions
- More robust clock synchronization
- Better handling of receiver state transitions
- Fixed various race conditions in the show loading/execution flow

[IMAGE_PLACEHOLDER: Screenshot of system health indicators or error recovery]

None of this is exciting, but it's the difference between "works in testing" and "works when you actually need it to work." The system is way more resilient now.

## UI Improvements

I've been cleaning up the UI in various places. The show builder is more intuitive, the receiver status displays are clearer, and the inventory management is less clunky. It's still not winning any design awards, but it's functional and doesn't make me want to throw my laptop.

[IMAGE_PLACEHOLDER: Screenshot of updated UI showing improvements]

## What's Next?

The system is getting to the point where it's actually usable for real shows. I'm planning to use it for New Year's, which is why this release is NYE2025.01. After that, we'll see. There are always more features to add, but at some point you have to stop adding features and just use the thing.

The hardware side is solid. The software side is getting there. At this point, the biggest limitation is probably my ability to design good shows, not the system itself.

---

*As always, the code is open source. The hardware designs are available. If you want to build your own or contribute, go for it. Just don't be a dick about it.*

